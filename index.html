<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="script.js"></script>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="./jsicona.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
    <title>JavaScript Base</title>
</head>
<body>
    <div id="sfondo">
        <img src="spazio.jpg" alt="">
    </div>
    <div class="contenitore-primario">
        <div class="dati-base">
            <a href="https://github.com/MarcoGenoveseIta/javascript-basi" target="_blank" class="nome">
                <img class="img" src="github.png">
                Marco
            </a>
            <div><a href="https://www.google.com/search?client=firefox-b-d&q=cosa+%C3%A8+javascript" target="_blank" class="titos">JavaScript Basi</a></div>
            <a href="https://www.google.com/search?q=maggio+2023&client=firefox-b-d&sxsrf=APwXEdf1y5AHnAkXH05frZdY1iQhqYUOsA%3A1684825452385&ei=bGVsZImPF_T97_UP7PWJmAQ&ved=0ahUKEwiJ9eP074r_AhX0_rsIHex6AkMQ4dUDCA4&uact=5&oq=maggio+2023&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzILCAAQgAQQsQMQgwEyCwgAEIAEELEDEIMBMggIABCABBCxAzIFCAAQgAQyCwgAEIAEELEDEIMBMgsIABCABBCxAxCDATIFCAAQgAQyBQgAEIAEMgsIABCKBRCxAxCDATIFCAAQgAQ6CggAEEcQ1gQQsAM6AggmOggIABAWEB4QDzoICAAQFhAeEAo6BggAEBYQHkoECEEYAFCuBFjFDmCFEGgBcAF4AIABaYgB9AKSAQMzLjGYAQCgAQHIAQTAAQE&sclient=gws-wiz-serp" target="_blank" class="data">05/2023</a>
        </div>
            
        <div class="testos">
        
            <p class = "titolo">STRINGHE, NUMERi E ALTRI TIPI DI DATI IN JAVASCRIPT</p>

            in javascript ci sono 5 tipi di dati primitivi:<br>
            numeri, stringhe, boleani, null e undefinde e gli oggetti.<br>
            javascript converte un primitivo nel corrispondente oggetto <br> <br>
        
            <div class="es"><code class = esercizio>var nomeMaiuscolo = "Marco".toUpperCase();<br>
            console.log({nomeMaiuscolo});<br><br>
            var nomeMinuscolo = nomeMaiuscolo.toLocaleLowerCase();<br>
            console.log({nomeMinuscolo});</code></div><br>
            
            a partire dal tipo primitivo stringa, javascript crea il corrispondente oggetto string,<br> 
            invoca il metodo toUppercase() per ottenere la versione stringa.<br>
            contribuisce a creare non poca confisione nella distinzione tra dati primititvi e oggetti, <br> 
            non sono pochi a semplificare sostenendo che in realtà in javascript tutto è oggetto.
            
            <p class = "titolo">STRINGHE IN JAVASCRIPT</p>
            
            una stringa è una sequenza di caratteri delimitata da dopppi o singoli apici<br> <br>
            
            <div class="es"><code class = esercizio>var stringaNum1 = ("stringa num 1");<br>
            var stringaNum2 = ('stringa num 2');<br><br>
            console.log({stringaNum1});<br>
            console.log({stringaNum2});</code></div>
            
            <p class = "titolo">NUMERI IN JAVASCRIPT</p>
            
            javascript ha un unico tipo di dato numerico. ciè non c'è distinzione formale, esempio tra intero e decimale <br> <br>            
            
            <div class="es"><code class = esercizio>var interoNegativo = -3;<br>
            var zero = 0;<br>
            var interoPositivo = 333;<br><br>
            console.log({interoNegativo});<br>
            console.log({zero});<br>
            console.log({interoPositivo});</code></div><br>
            
            stessa cosa si può fare con i numeri scientifici, orrale, esadecimale e con le virgole.<br>
            ogni valoreche va al di fuori dell'intervallo rappresentabile non genera un'eccezione ma viene <br> 
            rappresentato da due valori speciali:<br> <br>
            
            <div class="es"><code class = esercizio>infinity (infinito positivo)<br>
            -infinity (infinito negativo)</code></div><br>
            
            ogni valore che ha un precisione maggiore di quella rappresentabile viene considerata unguale a zero.<br>
            un altro valore numerico è NaN (not a number) che indica un valore numerico non definito.
            
            <p class = "titolo">I TIPI DI DATO NULL, UNDEFINED E BOOLEANO</p>

            javascript prevete 2 tipi di dato speciali per rappresentare valori nulli e non definiti.<br>
            il tipo dato null prevede  il solo valore null, che rapresenta un valore che non rientra tra i tipi di dato <br>
            del linguaggi. <br> <br>           
            
            <div class="es"><code class = esercizio>var x = (null); <br> console.log({x});</code></div><br>
            
            il valore null è diverso dal valore numerico 0 o dalla stringa vuota. infatti questultimi appartengono a <br>
            tipi di numero stringa, mentr null è un tipo a se stante.<br>
            il tipo undefined rappresenta un valore che non esiste ed è il valore di una variabile non inizializzata a <br>
            cui non è stato assegnato nessin valore.<br>
            il booleano prevededue soli valori: vero e valso; true e folse; 1 e 0; (tutti modi per dire vero e falso).
            
            <p class = "titolo">TIPIZZAZIONE DEBOLE</p>
            
            javascript è un linguaggio a tipizzazione depore o dinamica. significa che quando dichiariamo una variabile, <br>
            non ne specifichiamo il tipo di dato che può contenere, può cambaire durante lo script.<br>
            quando dichiariamo una variabile senza specifichedi un valore, a questa ciene assegnato il valore undefined. <br>
            il valore può cambaire tramite le nostre istruzionied assumere tipi diversi di dato. <br> <br>           
            
            <div class="es"><code class = "esercizio">var miaVariabile;<br>
            miaVariabile = 3;<br>
            miaVariabile = null;<br>
            miaVariabile = "tre";<br>
            miaVariabile = true;<br><br>
            console.log({miaVariabile});</code></div> <br>
            
            l'assegnamento puù comunque avvvenire direttamente nella dichiarazione.
            
            <p class = "titolo">ESPRESSIONIE OPERATORI</p>
            
            un espressione è una combinazione di valori, variabili ed operatori che rappresentano un valore <br> <br>           
            
            <div class="es"><code class = esercizio>x + 1</code></div><br>
            
            nel caso si tratta di un espressione che combina una variabile x ed il valore numerico 1 tramite <br>
            l'operatore + (più) per ottenere l'incremento di un unità del valore x. <br>
            è evidente che un ruolo fondamentale nelle espressioni è assunto dagli operatori in base al numero di <br>
            valori che possono combinare uno, due o tre valori.
            
            <p class = "titolo">OPERATORI ARITMETICI</p>
            
            per quel che riguarda il tipo di dato numerico, abbiamo gli operatori aritmetici, che consentono la <br>
            combinazione di valori numerici. <br> <br>
                    
            <div class="es"> <code>
                <table>
                    <tr><td class="dato">operatore</td><td class="dato">nome</td></tr>
                    <tr><td class="dato">+</td><td class="dato">addizione</td></tr>
                    <tr><td class="dato">-<td class="dato">sottrazione</td></td>
                    <tr><td class="dato">/<td class="dato">divisione</td></td>
                    <tr><td class="dato">*<td class="dato">moltiplicazione</td></td>
                    <tr><td class="dato">%<td class="dato">modulo o resto</td></td>
                </table>
            </code></div> <br>
     
            <div class="es"><code class = esercizio>9/4<br>9%4 + 5 + 10</code></div> <br>
        
            seguono le regole di precedenza matematica<br><br>
        
            <div class="es"><code class = esercizio>(4 +5) * (6+7)<br>4 + 5 * 6 + 7</code></div><br>

            gli operatori aritmetici prevedono tre operatori unari:<br><br>
        
            <div class="es"><code>
                <table>
                    <tr><td class="dato">operatore</td><td class="dato">nome</td></tr>
                    <tr><td class="dato">-</td><td class="dato">negazione</td></tr>
                    <tr><td class="dato">++<td class="dato">incremento</td></td>
                    <tr><td class="dato">--<td class="dato">decremento</td></td>
                </table>
            </code></div><br>
        
            la negazione consente di ottenere un valore negativo di un numero. ad esempio, -x è il valore <br>
            negativo del valore numerico rappresentato dalla variabilex.<br>
            gli operatori incrementano e decrementano sono applicabili soltanto a variabili e consentono di <br>
            ottenere un valore rispettivamente aumentato o diminuito di uno.<br>
            viene eseguita prima della valutazione <br> <br>
     
            <div class="es"><code class = esercizio>var x = (3);<br>var y = (x++);<br>console.log({x} + {y})</code></div><br>

            il valore della variabile x verrà assegnato alal variabile y e soltanto sucessivamente x verrà incrementato <br>
            di uno.
        
            <p class = "titolo">OPERATORI RELAZIONARI</p>

            gli operatori relazionari sono quelli utilizzati per il confronto tra valori:
            <br><br>
            <div class="es"><code>   
                <table>
                    <tr><td class="dato">operatore</td><td class="dato">nome</td></tr>
                    <tr><td class="dato"><</td><td class="dato">minore</td></tr>
                    <tr><td class="dato"><=<td class="dato">minore o uguale</td></td>
                    <tr><td class="dato">><td class="dato">maggiore</td></td>
                    <tr><td class="dato">>=<td class="dato">maggiore o uguale</td></td>
                    <tr><td class="dato">==<td class="dato">uguale</td></td>
                    <tr><td class="dato">!=<td class="dato">diverso</td></td>
                    <tr><td class="dato">===<td class="dato">estremamente uguale</td></td>
                    <tr><td class="dato">!==<td class="dato">estremamente diverso</td></td>
                </table>     
            </code>   </div><br> 

            le espressioni che utilizzano gli operatori relazionari restuituiscono ub valore booleano in base <br> 
            all' esito del confronto. <br> <br>
        
            <div class="es"><code class = esercizio>4 > 2 //true<br>5 != 4 + 1 //folse</code> </div><br>
        
            il significato della maggior parte degli operatori devrebbe essere abbastanza intuitivo.<br>
            gli operatori logici consentono la combinazione di espressione booleane:
            <br><br>
            <div class="es"><code>
                <table>
                    <tr><td class="dato">operatore</td><td class="dato">nome</td></tr>
                    <tr><td class="dato">&&</td><td class="dato">and</td></tr>
                    <tr><td class="dato">||<td class="dato">or</td></td>
                    <tr><td class="dato">!<td class="dato">not</td></td>
                </table>
            </code></div>     <br>     
        
            <div class="es"><code class = esercizio>(5 > 2) && (3 !=4) // true<br>
            true || (4 >= 6) // true<br>
            !(5==5) // false</code></div>
            
            <p class = "titolo">OPERATORI DI ASSEGNAMENTO</p>
            
            l' espressione di assegnamento restituisce essa stessa un valore dell' espressione assegnata alla variabile:
            <br> <br>
            
            <div class="es"><code class = esercizio>x = 3 + 5;<br>
            y = (x = 3 + 5);<br>
            (x = 5? "cinque" : "diverso da cinque")</code></div>
            
            <p class = "titolo">OPERATORE '?', PER ASSEGRAMENTI CONDIZIONALI</p>
            
            l' unico operatore ternario da javascript è l' operatore condizionale.<br>
            esse restituisce un valore in base ad una espressione boleana. la sua sintassi è:<br><br>
            
            <div class="es"><code class = esercizio>condizione ? valore1 : valore2<br>
            x%2 == 0 ? "pari" : "dispari"<br></code></div>
            
            <p class = "titolo">OPERATORI DI ESSEGNAMENTO COMPOSTI</p>
            
            oltre all (=), esistono altri operatori di assegnamento derivanti dalla combinazione degli operatori <br>
            aritmetici e degli operatori sui bit con il simbolo =. <br>
            essi rappresentano uanabbreviazione <br> <br>
            
            <div class="es"><code class = esercizio>x += 3;</code></div> <br>
        
            
            <div class="es"><code class = esercizio>x = x + 3;</code></div><br>
            
            analogicamente abbiamo a disposizione gli operatori come:<br><br>
            
            <div class="es"><code>
                <table>
                    <tr><td class="dato">forma compatta</td><td class="dato">scrittura equivalente</td></tr>
                    <tr><td class="dato">x += y</td><td class="dato">x = x + y</td></tr>
                    <tr><td class="dato">x -= y<td class="dato">x = x - y</td></td>
                    <tr><td class="dato">x *= y<td class="dato">x = x * y</td></td>
                    <tr><td class="dato">x /= y<td class="dato">x = x / y</td></td>
                    <tr><td class="dato">x %= y</td><td class="dato">x = x % y</td></td>
                </table> 
            </code></div><br>
        
            l' uso di queste espressioni rende più compatibile il codice ma non sempre altrttanto leggibile.

            <p class = "titolo">OPERATORI SU STRINGHE</p>
        
            l' unico operatore su stringhe specifico è operatore concatenazione. esso consente di creare una nuova <br>
            stringha come risultato delal concatenazione.<br>
            esso consente di creare una nuova stringa come risultato della concatenazione ed è rapprensentato dal <br>
            simbolo del "più" (+): <br><br>
        
            <div class="es"><code class = esercizio>"piano" + "forte" // "pianoforte"</code></div> <br>
        
            <div class="es"><code class = esercizio>var strumento1 = "piano";<br>
            var strumento2 = "forte";<br><br>
            console.log({strumento1} + {strumento2});</code></div><br>
            
            <div class="es"><code class = esercizio>var strumento= "piano";<br>
            strumento += "forte";<br>
            console.log({strumento})</code></div><br>
            
            il suo utilizzo è abbastanza immediato, ma con le variabili si possono ottenere risultati non <br>
            prebisti dal momento che il simbolo utilizato è lo stesso dell' addizione. <br> <br> 
            
            <div class="es"><code class = esercizio>x + y</code></div>
            
            <p class = "titolo">CONVERSIONI TRA TIPI DI VARIABILI</p>
            
            effettua conversioni implicite <br> <br>
            
            <div class="es"><code class = esercizio>var x = "12";<br>    
            var y = "13";<br>
            var calcolo =  x * y;<br><br>
            console.log({calcolo})</code></div><br>
            
            conversione implicita delle variabili in booleano <br> <br>
            
            <div class="ess"><code class="esercizio">(3) {<br><br>
                console.log("vero")<br>
            }else{<br><br>
                console.log("falso");<br>
            }<br>
            operatore terrario<br>
            let ter1 = 3 ? "vero" : "falso";<br>
            console.log({ter1});<br><br>
            let ter2 = 0 ? "vero" : "falso";<br>
            console.log({ter2});<br><br>
            let ter3 = undefined ? "vero" : "falso";
            console.log({ter3});<br><br>
            let ter4 = null ? "vero" : "falso";<br>
            console.log({ter4});<br><br>
            let ter5 = true ? "vero" : "falso"<br>
            console.log({ter5})<br><br>
            let ter6 = false ? "vero" : "falso";<br>
            console.log({ter6})<br><br>
            let ter7 = NaN ? "vero" : "falso";<br>
            console.log({ter7})<br><br>
            let ter8 = Infinity ? "vero" : "falso"<br>
            console.log({ter8})<br><br>
            let ter9 = (4 * 2) % 3 - (9 % 0) ? "vero" : "falso"<br>
            console.log({ter9})<br><br>
            let ter10 = 5=="5" ? "vero" : "falso";<br>
            console.log({ter10})<br><br>
            let ter11 = 3!==2 ? "vero" : "falso";<br>
            console.log({ter11})<br><br>
            let ter12 = 14 > 12 ? "vero" : "falso";<br>
            console.log({ter12})</code></div>
        
            <p class = "titolo">BLOCCHI DI CODICE</p>
        
            nei blocchi di codice più istruzzioni possono essere ragruppate esempio:
            <br> <br>
        
            <div class="es"><code class = esercizio>{<br>
                x = x + 3;<br>
                x = x * 2;<br>
            }</code></div><br>
        
            al termine del blocco non va inserito (;)
        
            <p class = "titolo">ISTRUZZIONI CONDIZZIONALI: IF</p>
        
            le istruzioni condizionali sono una categoria di istruzioni che consentono di eseguire blocchi di <br>
            codice alternativi in base ad una conizione, consentono script di prendere senso alle decisioni. <br>
            javascript prevede 2 istuzioni condizionali:<br><br>
        
            <div class="es"><code class = esercizio>- if semplice<br>
            - ifa alternativa (else)<br>
            - if a cascata (if esle if else)</code></div> <br>
            
            la forma if pura esegue un blocco di codice solo se una condizione è vera: <br> <br>            
            
            <div class="es"><code class = esercizio>if (condizione) {<br>istruzioni<br>
            }</code></div><br>
            dove condizione è un'espressione booleana e istruzioni rappresenta appunto la sequenza di <br>
            istruzioni da eseguire nel caso in cui la condizione sia veraif eslse:<br>
            if eslse viene eseguito un blocco di codice oppure un altro valore delal condizione: <br> <br>
        
            <div class="es"><code class = esercizio>if: (condizione) {<br>
                istruzioni1<br>
            } else {<br>
                istruzioni2<br>
            }</code></div><br>
        
            Se condizione è vera vengono eseguite le istruzioni del blocco istruzioni1 altrimenti viene eseguito <br>
            il blocco istruzioni2<br>
            if a cascata:<br>
            mette a disposizione più alternative: <br> <br>

            <div class="es"><code class = esercizio>if (condizione1) {<br>
                istruzioni1<br>
            } else if (condizione2) {<br>
                istruzioni2<br>
            } else {<br>
                istruzioni3
            }</code></div><br>
        
            In questo caso, se condizione1 è vera viene eseguito il blocco istruzioni1.<br>
            Se condizione1 non è soddisfatta viene verificata condizione2 e in base al suo valore <br>
            verrà eseguito il blocco istruzioni2 o istruzioni3<br>
            le if si usano per dare condizione eistruzioni per cambiare variare le opzioni <br> <br>
        
            <div class="es">if:<br>
            <code class = esercizio>if else:<br> if (x >= 37) {<br>
                messaggio = "Hai la febbre.\n";<br>
                messaggio = messaggio + "Temperatura: " + x + " gradi."; <br>
            }</code></div><br>
        
            <div class="es">if else:<br>
            <code class = esercizio>if else:<br>
            if (x%2 == 0) {<br>
                messaggio = x + " è pari";<br>
            } else {
                messaggio = x + " è dispari";<br>
            }</code></div> <br>
        
            <div class="es">if a cascata:<br>
            <code class = esercizio>if (x >= 37) {<br>
            messaggio = x + " è pari";<br>
            } else if (x%2 == 0) {
            messaggio = x + " è dispari";<br>
            } else {<br>
            messaggio = x + " è qualcosa";<br>
            }</code></div><br>
        
            <div class="es"><code class = esercizio>console.log(messaggio1)<br>
            console.log(messaggio2)<br>
            console.log(messaggio3)<br></code></div>
            
            <p class="titolo">WHILE E DO-WHILE, LE INTERAZIONE BASE</p>
            
            javascript prevede al classiche istruzioni di itatazione come while e for<br> <br>
         
            <div class="es"><code class = esercizio>while (condizione) {<br>
            //istruzioni<br>
            }</code></div><br>
        
            Requisito fondamentale nell'uso del while è che le istruzioni contenute nel blocco di codice <br>
            modifichino la condizione, altrimenti si rischia di incorrere in un ciclo infinito <br> <br>

            <div class="es"><code class = esercizio>var y = 1;<br>
            ver i = 1;<br>
            while (i <= 4) {<br>
            y = y * i; <br>
            i++; <br>
            }</code></div> <br>
        
            Da notare come l'incremento della variabile i garantisca l'uscita dal ciclo, dal momento che al <br> 
            superamento del valore 4 renderà la condizione falsa

            <p class="titolo">DO-WHILE</p>
        
            Una variante del while è il do...while  <br> <br>

            <div class="es"><code class = esercizio>do { <br>
                // istruzioni <br>
            } <br>
            while (condizione)</code></div> <br> 
        
            Questo garantisce che il blocco di codice verrà eseguito almeno una volta

            <p class="titolo">ARRAY IN JAVACSRIPT</p>

            gli array sono lo stile numerate in oggetti anche di tipo diverso <br>
            consentono di associare più valori ad un unico variabile. <br>
            l'uso di array evita di definire più variabili e semplifica  lo svolgimento di operazioni <br> <br>

            <div class="es"><code class = esercizio>var giorniDellaSettimana = [ <br>
                "lunedì", <br>
                "martedì", <br>
                "mercoledì", <br>
                "giovedì", <br>
                "venerdì", <br>
                "sabato", <br>
                "domenica"];</code></div> <br>

            questo è un modo di definire un array basato sulla rappresentazione letterale <br>
            dopo aver definito un arrat possiamo accedere ai singoli elementi <br> <br>

            <div class="es"><code class = esercizio>var primoGiorno = giorniDellaSettimana[0];</code></div><br>

            si può fare anche con più elementi <br> <br>

            <div class="es"><code class = esercizio>var terzoGiorno = giorniDellaSettimana[2]; <br>
                var settimoGiorno = giorniDellaSettimana[6];</code></div>

            <p class="titolo">DEFINIRE UN ARRAY</p>

            un array può essere vuoto, cioè senza elementi, ed rappresentato dalle sole quadre ([]) <br> <br>

            <div class="es"><code class = esercizio>var myArray = [,"elemento"];</code></div> <br>

            otterremo un array con due elementi di cui il primo e un undegìfined. <br> 
            se invece l' elemento finale non è indicato: <br> <br>

            <div class="es"><code class = esercizio>var myArray = ["elemento", "altroelemento",];</code></div> <br>

            javascript ignorerà l'ultima virgola generando un array di due soli elementi <br>
            gli elementi di un array possono essere di qualsiasi tipo di dato previsto da javascript <br> <br>

            <div class="es"><code class = esercizio>var myArray = [123, "stringa", true, null];</code></div> <br>

            ci possono essere array dentro array <br> <br>

            <div class="es"><code class = esercizio>var myArray = [123, "stringa", ["a", "b", 99]];</code></div> <br>

            un questo caso epr accedera a 99 dovremmo accedere prima al terzo alemento principale <br>
            poi al terzo elemento dell' array contenuto un esso: <br> <br>

            <div class="es"><code class = esercizio>var novantanove = myArray[2][2];</code></div> 
            
            <p class="titolo">ARRAY MULTIDIMENSIONALI</p>

            la presenza di array come elementi di altri array ci consente di definire <br> 
            array multidimensionali o matrici. <br> <br>

            <div class="es"><code class = esercizio>var matrice = [[24, 13, 1], [48, 92, 17], [8, 56, 11]]</code></div> <br>

            per accedere al num 48 indicheremo le sue coordinate: <br> <br>

            <div class="es"><code class = esercizio>var quarantotto = matrice[1][0];</code></div>

            <p class="titolo">DESTRUTTURAZIONE DELL' ASSEGNAMENTO</p>

            sfruttanto un meccanismo chiamato destrutturazione dell' assegnamento possiammo riscrivere <br> 
            assegnamenti: <br> <br>

            <div class="es"><code class = esercizio>var [primoGiorno,,terzoGiorno,,,,settimoGiorno] = giorniDellaSettimana;</code> </div> 

            <p class="titolo">I CICLI FOR</p>

            un alternativa al while è l'istruzione for <br>
            generalmente intesa come un blocco di codice numero determinato più volte <br> <br>

            <div class="es"><code class = esercizio>for (inizializzazione; condizione; modifica) { <br>
                // istruzioni <br>
            }</code></div> <br>

            - javascript esegue l' istruzione specificata in inizializzazione prima di avviare ciclo <br> <br>

            - l' espressione booleana che viene valutata prima di eseguire ciascuna iterazione <br> <br>

            - al termine di ciascuna iterazione viene eseguita l'istruzione modifica <br> <br>

            in questo caso è responsabilità nostra <br> <br>
            
            <div class="es"><code class = esercizio>var y = 1; <br>
                var i; <br>
                for (i = 1; i <=4; i++) { <br>
                    y = y * i; <br>
                }</code></div> <br>

            abbiamotrasposto gli elementi del while all' interno dello schema sintattico del for <br>
            il for è generalmente comodo per effettuare operazioni sugli array, ciclando tra gli elementi <br> <br>



            <div class="es"><code class = esercizio>var quantita = [12, 34, 45, 7, 19]; <br>
                var totale = 0; <br>
                var i; <br>
                for (i = 0; i < 5; i++) { <br>
                    totale = totale + quantita[i]; <br>
                }</code></div>

            <p class="titolo">INIZIALLIZZAZIONI MULTIPLE O VUOTE</p>

            l' istruzione for è molto flessibile infatti possiamo <br> 
            inserire nelle sezioni inizializzazione e modifica anche gruppi di istruzioni separati da virgole <br>  <br>

            <div class="es"><code class = esercizio>var y; <br>
                var i; <br>
                for (i = 1, y = 1; i <=4; i++) { <br>
                    y = y * i; <br>
                }</code></div> <br>

            Possiamo ad esempio, scrivere il nostro ciclo in questo modo del tutto equivalente <br> <br>

            <div class="es"><code class = esercizio>var y = 1; <br>
                var i = 1; <br>
                for (; i <=4; i++) { <br>
                    y = y * i; <br>
                }</code></div> <br>
            
            fino ad arrivare ad una situazione del genere sintatticamente quasi identica <br> <br>

            <div class="es"><code class = esercizio>var y = 1; <br>
                var i = 1; <br>
                for (; i <=4;) { <br>
                    y = y * i; <br>
                    i++; <br>
                }</code></div> 

            <p class="titolo">FOR-IN E FOR-OF</p>

            Per lavorare più comodamente con gli array JavaScript prevede due varianti <br> 
            del for: il for...in e il for...of. Vediamo come come scrivere le istruzioni precedenti <br> 
            facendo uso del for...in <br> <br>

            <div class="es"><code class = esercizio>var quantita = [12, 34, 45, 7, 19]; <br>
                var totale = 0; <br>
                var indice; <br>
                for (indice in quantita) { <br>
                    totale = totale +  quantita[indice]; <br>
                }</code></div> <br>

            fruttando questa variante del for non abbiamo bisogno di specificare la lunghezza <br> 
            dell'array nè l'istruzione di modifica della condizione  <br> <br>

            ad ogni iterazione javascript assegna alla variabile valore il contenuto di ciascun elemeto array <br>
            Queste varianti del for ci consentono di scrivere meno codice quando lavoriamo con gli array <br>

            <p class="titolo">DEFINIRE UNA FUNZIONE JAVACSRIPT</p>

            <div class="es"><code class = esercizio>function nome(argomenti) { <br>
                // istruzioni <br>
                }</code></div> <br>

            La parola chiave function evidenzia che stiamo dichiarando una funzione il cui nome segue le stesse <br> 
            regole dei nomi di variabili. <br>
            Una volta dichiarata, una funzione non viene eseguita subito. Stiamo semplicemente dicendo all'engine <br> 
            JavaScript che al blocco di codice indicato viene assegnato un nome 

            <p class="titolo">JS: INVOCARE UNA FUNZIOEN</p>

            <div class="es"><code class = esercizio>nome(valori);</code></div> <br>

            dove nome è il nome della funzione e valori è una lista opzionale di espressioni separata da virgole. <br>

            <p class="titolo">L' ISTRUZZIONE RETURN</p>

            Nel corpo della funzione può essere presente l'istruzione return che consente di terminare e restituire un valore <br> 
            al codice che l'ha chiamata <br> <br>

            <div class="es"><code class = esercizio>function somma() { <br>
                var z = 11 + 5;  <br>
                return z; <br>
                } <br>
                var risultato = somma();</code></div> <br>

            In questo esempio abbiamo definito una funzione senza argomenti che somma due interi e restituisce il risultato
            <br> <br>

            <div class="es"><code class = esercizio>var risultato = 5 + somma() * 2;</code></div> <br>

            In questo esempio l'invocazione somma() sarà equivalente al valore 16, per cui la variabile risultato avrà valore 37

            <p class="ARGOMENTI O PARAMETRI DI UNA FUNZIONE"></p>

            La funzione somma() che abbiamo definito prima è in grado di sommare soltanto i due numeri fissati nel <br> 
            blocco di istruzioni <br> <br>

            <div class="es"><code class = esercizio>function somma(x, y) { <br>
                var z = x + y; <br>
                return z; <br>
                }</code></div> <br>

            In questo caso i valori da sommare verranno passati alla funzione somma() al momento dell'invocazione:
            <br> <br>

            <div class="es"><code class = esercizio>var risultato = somma(11, 5);</code></div>

            <p class="titolo">PARAMETRI OPZIONALI</p>

            Come abbiamo avuto modo di vedere, JavaScript è un linguaggio molto flessibile e questa sua <br> 
            flessibilità ci consente di fare delle cose che talvolta possono apparire abbastanza strane <br> <br>

            In altre parole, data la definizione della funzione somma() con i due argomenti da sommare, <br> 
            possiamo invocare la funzione nei seguenti modi <br> <br>

            <div class="es"><code class = esercizio>var risultato1 = somma(11); <br>
                var risultato2 = somma(); <br>
                var risultato3 = somma(11, 5, 7, 9);</code></div> <br>
            
            Queste tre invocazioni della funzione somma() potrebbero apparire errate, <br> 
            ma non generano nessun errore in JavaScript  

            <p class="titolo">L' ARRAY ARGUMENTS</p>

            Una analoga flessibilità l'abbiamo anche nella dichiarazione degli argomenti quando definiamo <br> 
            una funzione. Ad esempio, possiamo non definire alcun argomento nella definizione di somma() <br> 
            ed accedere ai valori passati in fase di chiamata tramite un array speciale predefinito: arguments. <br> <br>

            <div class="es"><code class = esercizio>function somma() { <br>
                var z = arguments[0] + arguments[1]; <br>
                return z; <br>
                }</code></div> <br>

            In questo caso non specifichiamo gli argomenti a fianco al nome della funzione, ma accediamo ad <br> 
            essi sfruttando questo array predefinito. <br> <br>

            possiamo sommare un numero indefinito di valori: <br> <br>

            <div class="es"><code class = esercizio>function somma() { <br>
                var z = 0; <br>
                var i; <br>
                for (i in arguments) { <br>
                z = z + arguments[i]; <br>
                } <br>
                return z; <br>
                }</code></div> <br>

            In questo modo potremo chiamare la funzione per sommare un qualsiasi numero di valori: <br> <br>

            <div class="es"><code class = esercizio>somma(2, 78); <br>
            somma(17, 32, 4, 19, 52);</code> </div>
            
            <p class="titolo">ARGOMENTI CON VALORI DI DEFAULT</p>

            arricchiscono la flessibilità della gestione degli argomenti di una funzione. <br> 
            In particolare viene introdotta la possibilità di specificare dei valori di default: <br> <br>

            <div class="es"><code class = esercizio>function somma(x = 0, y = 0) { <br>
                var z = x + y; <br>
                return z; <br>
                }</code></div> <br>
            
            In questo modo se al momento della chiamata non viene passato un argomento, <br> 
            ad esso viene assegnato il valore di default specificato, invece del valore undefined.

            <p class="titolo">JAVACSRIPT: REST PARAMETER, ARGOMENTI AGGIUNTIVI</p>

            Supponiamo di voler definire una funzione che implementa diverse operazioni <br> 
            aritmetiche e prende come primo argomento il nome dell'operazione da eseguire <br> 
            ed a seguire un numero variabile di valori su cui effettuare l'operazione. <br> <br>

            <div class="ess"><code class = esercizio>function eseguiOperazione(x, ...y) { <br>
                var z = 0; <br>
                switch (x) { <br>
                case "somma": <br>
                for (i in y) { <br>
                z = z + y[i]; <br>
                } <br>
                break; <br>
                case "moltiplica": <br>
                for (i in y) { <br>
                z = z * y[i]; <br>
                } <br>
                break; <br>
                case "dividi": <br>
                z = y[0]/y[1]; <br>
                break; <br>
                default: <br>
                z = NaN; <br>
                break; <br>
                } <br>
                return z; <br>
                }</code></div> <br>
            
            Come possiamo vedere, abbiamo specificato un argomento x che rappresenta il <br> 
            nome dell'operazione da eseguire e un argomento y preceduto da tre punti che <br> 
            rappresenta il resto dei valori da passare alla funzione <br> <br>

            La notazione dell'argomento preceduto dai puntini cattura l'elenco degli <br> 
            argomenti successivi al primo e lo rende disponibile all'interno della funzione <br> 
            sotto forma di array <br> <br>

            L'approccio è simile all'array predefinito arguments, ma mentre questo <br>
            cattura tutti gli argomenti della funzione, il rest parameter cattura soltanto <br> 
            gli argomenti in più rispetto a quelli specificati singolarmente <br> <br>

            <div class="es"><code class = esercizio>eseguiOperazione("somma", 12, 54, 2, 7, 12); <br>
                eseguiOperazione("moltiplica", 4, 11, 32); <br>
                eseguiOperazione("dividi", 45, 9, 6, 17);</code></div> <br>

            La prima e la seconda chiamata otterranno rispettivamente la somma ed il prodotto dei valori <br> 
            passati dal secondo argomento in poi, mentre la terza chiamata otterrà la divisione del <br> 
            secondo e terzo argomento, ignorando gli altri <br> <br>

            La stessa notazione del rest parameter può essere utilizzata nelle <br> 
            chiamate a funzioni che prevedono diversi argomenti <br> <br>

            <div class="es"><code class = esercizio>var addendi = [8, 23, 19, 72, 3, 39]; <br>
                somma(...addendi);</code></div> <br>

            La chiamata con lo spread operator è equivalente alla seguente chiamata: <br> <br>

            <div class="es"><code class = esercizio>somma(8, 23, 19, 72, 3, 39);</code></div>

            <p class="titolo">RESTITUZIONE DI VALORI</p>

            Abbiamo visto come una funzione possa restituire un valore al codice chiamante <br> 
            tramite l'istruzione return. <br> <br>

            Se una funzione non ha un valore da restituire, infatti, può omettere il return <br> 
            o presentare l'istruzione senza un valore esplicito <br> <br>

            <div class="es"><code class = esercizio>function msg(messaggio) { <br>
                alert(messaggio); <br>
                }</code></div> <br>
            
            <div class="es"><code class = esercizio>function msg(messaggio) { <br>
                alert(messaggio); <br>
                return; <br>
                }</code></div> <br>

            Se proviamo ad assegnare ad una variabile il valore restituito in entrambi <br> 
            i casi otterremo il valore undefined <br> <br>

            L'effetto dell'esecuzione di return è la terminazione della funzione e la restituzione di un valore <br> <br>

            <div class="ess"><code class = esercizio>function decodifica(numero) { <br>
                switch(numero) { <br>
                case "uno": <br>
                return 1; <br>
                break; <br>
                case "due": <br>
                return 2; <br>
                break; <br>
                case "tre": <br>
                return 3; <br>
                break; <br>
                default: <br>
                return NaN; <br>
                break; <br>
                } <br>
                }</code></div> <br>

            In questo esempio, la funzione termina e restituisce un valore non appena individua <br> 
            una corrispondenza con l'argomento, quindi le istruzioni break sarebbero superflue nel caso specifico <br> <br>

            Tuttavia è buona norma limitare il numero di return presenti in una funzione, riducendoli possibilmente a <br> 
            uno soltanto <br> <br>

            <div class="ess"><code class = esercizio>function decodifica(numero) { <br>
                var risultato; <br>
                switch(numero) { <br>
                case "uno": <br>
                risultato = 1; <br>
                break; <br> 
                case "due": <br>
                risultato = 2; <br>
                break; <br>
                case "tre": <br>
                risultato = 3; <br>
                break; <br>
                default: <br>
                risultato = NaN; <br>
                break; <br>
                } <br>
                return risultato; <br>
                }</code></div>
            
            <p class="titolo">VARIABILI GLOBALI E LOCALI: LO SCOPE</p>

            Queste variabili sono accessibili soltanto all'interno della <br> 
            funzione e non vengono viste fuori di essa o, in termini tecnici, hanno uno scope locale <br> <br>

            Lo scope o ambito di visibilità di una variabile è la parte di uno script all'interno <br> 
            del quale si può fare riferimento ad essa <br>
            Le variabili dichiarate all'interno di una funzione sono dette locali alla funzione dal momento <br> 
            che sono accessibili soltanto all'interno del suo corpo. <br> <br>

            Le variabili dichiarate fuori da qualsiasi funzione sono dette globali e sono accessibili <br> 
            da qualsiasi punto dello script, anche all'interno di funzioni <br> <br>

            <div class="es"><code class = esercizio>var x = 10; <br>
                var y; <br>
                function incrementa(){ <br>
                        var z = 5; <br>
                    x = x + z; <br>
                } <br>
                incrementa(); <br>
                y = x + 1;</code></div> <br>

            Nell'esempio abbiamo dichiarato due variabili globali x e y. Entrambe sono accessibili anche <br> 
            all'interno della funzione incrementa() e infatti la funzione accede a x per incrementarla del <br> 
            valore della variabile locale z. <br> <br>

            Il valore della variabile x dopo l'invocazione della funzione incrementa() sarà <br> 
            pertanto 15 ed il valore finale assegnato a y sarà 16. <br> <br>

            Variabili locali e globali possono avere lo stesso nome, ma in questo caso si vengono a creare <br> 
            delle ambiguità la cui risoluzione dipende dalla regola secondo cui si fa riferimento <br> 
            all'ambito di visibilità più vicino all'utilizzo della variabile <br> <br>

            <div class="es"><code class = "esercizio">var x = 10; <br>
                var y; <br>
                function incrementa() { <br>
                    var x = 5; <br>
                    x = x + 1; <br>
                    return x; <br>
                } <br>
                incrementa(); <br>
                y = x + 1;</code></div> <br>
            
            all'interno del corpo della funzione incrementa() viene dichiarata una variabile <br> 
            locale con lo stesso nome della variabile globale x. In questo caso il riferimento a x all'interno <br> 
            della funzione è inteso come il riferimento alla variabile locale, in quanto lo scope locale è il <br> 
            più vicino all'uso della variabile <br> <br>

            indipendentemente dal punto in cui viene dichiarata una variabile, essa <br> 
            esiste in tutto lo scope a cui appartiene <br> <br>

            <div class="es"><code class ="esercizio"> var x = 10; <br>
                var y; <br>
                function incrementa() { <br>
                    var s = x; // x ha valore undefined <br>
                    var x = 5; // x ha valore 5 <br>
                    x = x + s; // x ha valore NaN <br>
                    return x; <br>
                } <br>
                incrementa(); <br>
                y = x + 1;     // x ha valore 10</code></div> <br>

            All'interno della funzione incrementa() abbiamo utilizzato la variabile x prima della sua dichiarazione <br>
            x non fa riferimento alla variabile globale, ma a quella locale dichiarata subito dopo e il suo valore <br> 
            è ancora undefined <br> <br>

            In altre parole, nel seguente esempio la variabile y è accessibile anche al di fuori del blocco <br> 
            associato all'istruzione if <br> <br>

            <div class="es"><code class ="esercizio">function rendiPari(x) { <br>
                if (x%2 != 0) { <br>
                    var y; <br>
                    y= x + 1; <br>
                } else { <br>
                    y = x; <br>
                } <br>
                return y; <br>
            }</code></div> <br>

            è opportuno dichiarare le variabili all'inizio del proprio scope, ad esempio all'inizio del corpo <br> 
            di una funzione, in modo evidenziare quali variabili saranno disponibili
            
            <p class="titolo">LET</p>

            Se invece abbiamo bisogno di creare uno scope specifico per una o più variabili possiamo <br> 
            ricorrere all'istruzione let <br> <br>

            <div class="es"><code class ="esercizio">var x = 10; <br>
                var y; <br>
                { <br>
                  let x = 20; <br>
                  y = x + 1; <br>
                } <br>
                y = x + y;</code></div> <br>

            avremo uno scope a livello di blocco di codice in cui la variabile x dichiarata tramite let <br> 
            nasconde quella esterna dichiarata con var <br> <br>

            Un ambito in cui è senz'altro utile utilizzare l'istruzione let è nelle iterazioni, come <br> 
            ad esempio nel for <br> <br>

            <div class="es"><code class ="esercizio">var x = 0; <br>
                for (let i = 0; i < 10; i++) { <br>
                    x = x + 1; <br>
                }</code></div> <br>

            Grazie a let dichiariamo ed utilizziamo la variabile i soltanto all'interno del for, evitando <br> 
            eventuali collisioni con altre variabili omonime definite in scope più esterni <br> <br>
            
            Come possiamo intuire, la distinzione tra scope globale e locale delle variabili è in realtà <br> 
            troppo semplicistica

            <p class="titol">FUNZIONI PREDEFINITE</p>

            JavaScript dispone di alcune funzioni predefinite che risultano utili in alcune attività. <br> 
            Esse possono essere invocate in qualsiasi punto di uno script senza particolari distinzioni <br> 
            dalla chiamata di una funzione definita da noi

            <p class="titolo">PARSEINT E PARSEFLOAT</p>

            Abbiamo già avuto modo di vedere le funzioni parseInt() e parseFloat() per convertire <br> 
            una stringa rispettivamente in un valone numerico intero e decimale <br> <br>

            la funzione parseInt() prevede due parametri: il primo è la stringa da convertire, <br> 
            mentre il secondo è opzionale e indica la base del sistema di rappresentazione numerica utilizzato <br> <br>
        
            La funzione parseFloat() invece prevede un solo argomento e restituisce un valore numerico intero o <br> 
            decimale in base alla presenza del separatore decimale

            <p class="titolo">ISNAN E IS FINITE</p>

            Rimanendo sempre nell'ambito dei numeri abbiamo le funzioni isNaN() e isFinite() <br> <br>

            La funzione isNaN() prende un argomento e restituisce true se il suo valore è NaN, cioè non <br> 
            è un valore numerico valido, false altrimenti <br> <br>

            Analogamente, isFinite() restituisce true se il valore del suo argomento è diverso da Infinity e da NaN

            <p class="titolo">ESCAPE E UNESCAPE</p>

            Date le sue origini strettamemte legate al Web, JavaScript mette a disposizione una serie <br> 
            di funzioni predefinite per la codifica e decodifica di stringhe destinate a viaggiare sulla rete <br> <br>

            In particolare la funzione escape() restituisce la codifica una stringa lasciando inalterate <br> 
            cifre, lettere e i caratteri +-*/._@ e rimpiazzando tutti gli altri caratteri con la codifica <br> 
            esadecimale preceduta da un carattere percentuale (%). Il seguente è un esempio di uso della funzione <br> 
            escape() <br> <br>
            
            <div class="es"><code class ="esercizio">var stringa = escape("Questa è una stringa!");</code></div> <br>

            La variabile stringa conterrà il valore Questa%20%E8%20una%20stringa%21 dove al posto degli <br> 
            spazi, della e accentata e del punto esclamativo è stata sostituita la corrispondente codifica <br> 
            esadecimale <br> <br>

            La funzione unescape() esegue il procedimento contrario convertendo le codifiche esadecimali <br> 
            nei corrispondenti caratteri ASCII

            <p class="titolo">FUNZIONI DEPRECATE</p>

            Le funzioni escape() e unescape() sono considerate obsolete sin dalla versione 3 dello standard <br> 
            ECMAScript. Esse vengono migliorate e sostituite dalle funzioni di codifica e decodifica degli URI, <br> 
            che stiamo per vedere, tuttavia sono ancora supportate dalla maggior parte degli engine JavaScript per <br> 
            questioni di compatibilità. In definitiva è meglio evitare di utilizzarle e preferire le funzioni come <br> 
            encodeURI che stiamo per esaminare.

            <p class="titlo">ENCODEURI E DECIDEURI</p>

            Quando una stringa rappresenta un URI non è opportuno utilizzare la funzione escape() per la <br> 
            codifica, in quanto verrebbero codificati alcuni caratteri speciali, come ad esempio ? e #, che <br> 
            hanno un significato speciale <br> <br>

            In presenza di un URI utilizziamo la funzione encodeURI() che esclude dalla codifica i <br> 
            caratteri , /?:@&=+$# <br> <br>

            <div class="es"><code class ="esercizio">var escapedURI = escape(url.html"); <br>
                var encodedURI = encodeURI("url.html");</code></div> <br>
            
            la variabile escapedURI avrà il valore http%3A//www.html.it/a%20b.html mentre encodedURI conterrà <br> 
            il valore url. <br> <br>

            La controparte di encodeURI() è la funzione decodeURI() che, come è intuibile, restituisce la <br> 
            stringa decodificata

            <p class="titolo">ENCODEURI E DECIDEURI</p>

            La funzione encodeURIComponent() codifica anche i caratteri speciali esclusi dalla encodeURI(). <br> 
            Essa è pensata per codificare i valori di eventuali parametri passati in un URI <br> <br>

            <div class="es"><code class ="esercizio">var param = encodeURIComponent("Che cos'è?"); <br>
                var encodedURI = encodeURI("https://www.html.it/a b.php?x=") + param;</code></div> <br>

            Il valore finale della variabile encodedURI sarà: <br> <br>

            <div class="es"><code class ="esercizio">https://www.html.it/a%20b.php?x=Che%20cos'%C3%A8%3F</code></div> <br>

            il valore originario codificato da encodeURIComponent() conteneva il simbolo del punto <br> 
            interrogativo (?) che se non codificato avrebbe generato un URI malformato <br> <br>

            Come è presumibile, la corrispondente funzione per la decodifica è decodeURIComponent()

            <p class="titolo">EVAL</p>

            Tra le funzioni predefinite, eval() ha un ruolo controverso. <br> 
            Essa prende come argomento una stringa e la valuta o la esegue come se fosse codice JavaScript. <br>
            La stringa può rappresentare un'espressione o una serie di istruzioni <br> <br>

            <div class="es"><code class ="esercizio">var x = eval("5 + 1"); <br>
                var z = eval("x + 1"); <br>
                eval("var a = 4; a = a *3;"); <br>
                a = a + 1;</code></div> <br>

            La prima istruzione valuta un'espressione numerica e la assegna alla variabile x, <br> 
            che assume quindi il valore di 6. <br> 
            La seconda istruzione valuta una stringa che contiene la variabile x incrementandone il <br> 
            valore di uno. <br> La variabile z avrà il valore di 7. <br> 
            Questo ci fa capire che lo scope di riferimento di eval() è lo scope corrente. <br> <br>

            Infine l'ultima invocazione di eval() esegue due istruzioni JavaScript creando <br> 
            nello scope corrente la variabile a il cui valore finale sarà 13. <br> <br>

            Le potenzialità di eval() sono enormi, dal momento che mette a disposizione del <br> 
            programmatore un vero e proprio interprete JavaScript. <br>
            Insieme alle potenzialità anche il pericolo di avere risultati inattesi e non <br> 
            facilmente controllabili è alto, tanto che è stato detto che eval is evil. <br> <br>

            Diciamo che in linea di massima è opportuno evitare di utilizzare questa <br> 
            funzione perchè può creare più problemi di quelli che vorrebbe risolvere

            <p class="titolo">I NOMI DI FUNZIONI</p>

            A differenza delle parole chiavi di JavaScript, come i nomi delle istruzioni ed <br> 
            altri nomi riservati, i nomi delle funzioni predefinite non sono riservati. <br>
            Questo vuol dire che se tentiamo di definire una nostra funzione eval() o parseInt() <br> 
            non riceveremo un messaggio d'errore, ma ridefiniremo una nostra versione della funzione.

            <p class="titolo">TRY E CATCH</p>

            per modificare la scrittura degli errori si usa try con catch, in modo tale che da una stringa di <br>
            errore normale esca esempio questo è un errore. usando queste funzioni si può fare vedere <br>
            l' errore sul display come se fatto a posta. <br> <br>

            <div class="es"><code class ="esercizio"> let variabile = 0 <br>
            try { <br>
                variabile = funzione che vuoi selezionare (quella che potrebbe dare errori) <br>
            } catch (err) { <br>
                varibile = stringa di calcolo esempio: "errore" <br>
            } <br> 
            </code></div> <br>

            in questo modo al posto che uscire stringhe di calcolo fastidiose o intrlciante del progetto <br>
            uscirà solamente errore, come previsto.

        </div> 
    </div>
</body>
</html>